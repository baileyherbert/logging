{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is the documentation for <code>@baileyherbert/logging</code>. This package offers a logging solution based on a modular delivery concept. Simply create a logger instance, attach a delivery transport (such as console, file, or your own), and start logging!</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>npm install @baileyherbert/logging\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Create a logger instance. This is what we'll use to actually write output.</p> <pre><code>const logger = new Logger();\n</code></pre> <p>Create a console transport. This will print our output to the console. You can define a minimum log level for output. We'll use <code>Trace</code> here which will capture all levels of output.</p> <pre><code>logger.createConsoleTransport(LogLevel.Trace);\n</code></pre> <p>Create a file transport. This will send our output into a file. We'll set a minimum log level of <code>Information</code> to keep the logs minimal. Please note that the file transport has automatic log rotation enabled by default, but you can customize or disable this behavior.</p> <pre><code>logger.createFileTransport(LogLevel.Information, {\n    fileName: 'logs/output.log'\n});\n</code></pre> <p>Done! Now use the logger to write output to both the console and log file at once.</p> <pre><code>logger.trace('Starting example program');\nlogger.info('Hello world');\n</code></pre> <p>Both of those transports have many customization options, and you can also create your own. Check the transports guide to learn more.</p>"},{"location":"guide/logging/","title":"Logging","text":""},{"location":"guide/logging/#creating_a_logger","title":"Creating a logger","text":"<pre><code>const logger = new Logger();\n</code></pre> <p>You can also give the logger a name to help discern it in the output:</p> <pre><code>const logger = new Logger('Example');\n</code></pre> <p>You can create a filtered logger, which will only emit at or above the given log level:</p> <pre><code>const logger = new Logger('Example', LogLevel.Information);\n</code></pre> <p>You can create child loggers which forward output to the same transports:</p> <pre><code>const child = logger.createLogger();\nconst child = logger.createLogger('Child');\nconst child = logger.createLogger('Child', LogLevel.Information);\n</code></pre>"},{"location":"guide/logging/#attaching_transports","title":"Attaching transports","text":""},{"location":"guide/logging/#using_the_create_methods","title":"Using the <code>create</code> methods","text":"<p>There are methods on the <code>Logger</code> class to easily create and attach one of the built-in transports. For custom transports, you'll need to use the <code>attach</code> method as documented further below.</p> <pre><code>logger.createConsoleTransport();\n</code></pre> <pre><code>logger.createFileTransport({\n    fileName: 'console.log'\n});\n</code></pre> <p>Check the transports documentation to see the available options for these methods.</p>"},{"location":"guide/logging/#using_the_attach_method","title":"Using the <code>attach</code> method","text":"<p>When working with custom transports, or when you want to attach multiple root loggers to a single transport, you'll need to instantiate the transport manually and then attach the logger(s).</p> <pre><code>const transport = new ConsoleTransport({ /* options */ });\ntransport.attach(logger);\n</code></pre>"},{"location":"guide/logging/#getting_attached_transports","title":"Getting attached transports","text":"<p>The <code>transports</code> field on a logger will return an array of all attached transports, including those attached to parent logger(s). This is most useful for gracefully closing all attached transports:</p> <pre><code>await Promise.all(\n    logger.transports.map(transport =&gt; transport.close())\n);\n</code></pre>"},{"location":"guide/logging/#logging_levels","title":"Logging levels","text":"Name Value Description <code>Trace</code> <code>0</code> Logs that contain the most detailed messages. These messages can contain sensitive application data. These messages should not be used in a production environment. <code>Debug</code> <code>1</code> Logs that are used for interactive investigation during development. These logs should primarily contain information useful for debugging and have no long-term value. <code>Information</code> <code>2</code> Logs that track the general flow of the application. These logs should have long-term value. <code>Warning</code> <code>3</code> Logs that highlight an abnormal or unexpected event in the application flow, but do not otherwise cause the application execution to stop. <code>Error</code> <code>4</code> Logs that highlight when the current flow of execution is stopped due to a failure. These should indicate a failure in the current activity, not an application-wide failure. <code>Critical</code> <code>5</code> Logs that describe an unrecoverable application or system crash, or a catastrophic failure that requires immediate attention. <code>None</code> <code>6</code> Not used for writing log messages. Specifies that a logging category should not write any messages."},{"location":"guide/logging/#events","title":"Events","text":""},{"location":"guide/logging/#output","title":"<code>output</code>","text":"<p>This event is emitted when the logger receives new output from the application.</p> Argument Types Description <code>output</code> <code>LoggerOutput</code> An object containing details about the output message."},{"location":"guide/prefixes/","title":"Prefixes","text":"<p>The integrated console and file transports share the same prefix generator. This page documents the various options and customizations for your prefixes.</p>"},{"location":"guide/prefixes/#defaults","title":"Defaults","text":"<p>The default prefix configuration object looks like this:</p> <pre><code>{\n    includeLabels: true,\n    includeLoggerNames: true,\n    includeLabelAlignment: true,\n    timestamps: {\n        includeDates: false,\n        includeTimeMillis: true,\n        includeTimes: true,\n        includeTimeZone: false\n    },\n    customLabels: {\n        trace: 'Trace',\n        debug: 'Debug',\n        information: 'Info',\n        warning: 'Warn',\n        error: 'Error',\n        critical: 'Critical'\n    },\n    customBracketColors: undefined,\n    customHyphenColors: undefined,\n    customTimestampColors: chalk.gray,\n    customLabelColors: {\n        trace: chalk.reset,\n        debug: chalk.magentaBright,\n        information: chalk.greenBright,\n        warning: chalk.yellowBright,\n        error: chalk.redBright,\n        critical: chalk.redBright\n    },\n    customLoggerNameColors: undefined,\n    customLoggerBracketColors: undefined\n}\n</code></pre>"},{"location":"guide/prefixes/#labels","title":"Labels","text":"<p>Labels are a textual representation of the log level, such as <code>Information</code> or <code>Debug</code>.</p>"},{"location":"guide/prefixes/#timestamps","title":"Timestamps","text":"<p>Timestamps showcase the current time, date, and timezone.</p>"},{"location":"guide/prefixes/#logger_names","title":"Logger names","text":"<p>Logger names, when available, are added after the prefix in their own set of brackets.</p>"},{"location":"guide/prefixes/#colors","title":"Colors","text":"<p>All colors can be customized as shown within the defaults above. Each color component can be set to:</p> <ul> <li>A function from the <code>chalk</code> library, such as <code>chalk.red</code>.</li> <li>An object containing the various log levels as keys and <code>chalk</code> functions as values.</li> <li><code>undefined</code> to use the default.</li> </ul> <p>Note that you can use <code>chalk.reset</code> for any color to disable it.</p>"},{"location":"guide/transports/","title":"Transports","text":""},{"location":"guide/transports/#console_transports","title":"Console transports","text":"<p>This transport writes output to the console.</p>"},{"location":"guide/transports/#example","title":"Example","text":"<p>You can easily create a console transport with the <code>createConsoleTransport</code> method. The default options are shown below.</p> <pre><code>const transport = logger.createConsoleTransport({\n    destination: 'console',\n    formatting: {},\n    prefixes: {}\n});\n</code></pre>"},{"location":"guide/transports/#options","title":"Options","text":"Name Types Description Default <code>destination</code> <code>'console' | 'std'</code> Specifies whether output should be sent to the <code>console</code> functions or to <code>stdout</code>. <code>console</code> <code>formatting</code> <code>InspectOptions</code> Overrides specific options for <code>util.format()</code>. <code>{}</code> <code>prefixes</code> <code>PrefixGeneratorOptions</code> Customizes prefix generation. <code>{}</code>"},{"location":"guide/transports/#events","title":"Events","text":""},{"location":"guide/transports/#loggerattached","title":"<code>loggerAttached</code>","text":"<p>This event is emitted when a logger has been attached to the transport.</p> Argument Types Description <code>logger</code> <code>Logger</code> The logger that was attached."},{"location":"guide/transports/#loggerdetached","title":"<code>loggerDetached</code>","text":"<p>This event is emitted when a logger has been detached from the transport.</p> Argument Types Description <code>logger</code> <code>Logger</code> The logger that was detached."},{"location":"guide/transports/#file_transports","title":"File transports","text":"<p>This transport writes output to a log file with automatic rotation.</p>"},{"location":"guide/transports/#example_1","title":"Example","text":"<p>You can easily create a file transport with the <code>createFileTransport</code> method. The default options are shown below.</p> <pre><code>const transport = logger.createFileTransport({\n    fileName: 'console.log',\n    encoding: 'utf8',\n    eol: 'lf', // crlf for windows\n    formatting: {},\n    prefixes: {},\n    rotation: {\n        dirName: undefined, // defaults to same dir as fileName\n        maxFileSize: 16777216, // 16 MiB\n        maxArchiveCount: 10,\n        maxArchiveAge: 2678400000 // 31 days\n    },\n});\n</code></pre>"},{"location":"guide/transports/#options_1","title":"Options","text":"Name Types Description Default <code>fileName</code> <code>string</code> The name or path of the log file. required <code>encoding</code> <code>string</code> The encoding to use. <code>utf8</code> <code>eol</code> <code>'lf' | 'crlf'</code> The line endings to use. <code>crlf</code> for Windows <code>lf</code> for others <code>formatting</code> <code>InspectOptions</code> Overrides specific options for <code>util.format()</code>. <code>{}</code> <code>prefixes</code> <code>PrefixGeneratorOptions</code> Customizes prefix generation. <code>{}</code> <code>rotation</code> <code>object</code>, <code>false</code> Customizes automatic log rotation. See below <p>Rotation options:</p> Name Types Description Default <code>dirName</code> <code>string?</code> The name or path of the directory for archived logs. Same as log file. <code>maxFileSize</code> <code>number</code> The maximum size of the log file (in bytes) before rotation. <code>16777216</code> (16 MiB) <code>maxArchiveCount</code> <code>number</code> The maximum number of log archives to keep on the disk. Setting this to <code>0</code> will disable this feature. <code>10</code> <code>maxArchiveAge</code> <code>number</code> The maximum age of log archives (in milliseconds). Setting this to <code>0</code> will disable this feature. <code>2678400000</code> (31 days)"},{"location":"guide/transports/#events_1","title":"Events","text":""},{"location":"guide/transports/#loggerattached_1","title":"<code>loggerAttached</code>","text":"<p>This event is emitted when a logger has been attached to the transport.</p> Argument Types Description <code>logger</code> <code>Logger</code> The logger that was attached."},{"location":"guide/transports/#loggerdetached_1","title":"<code>loggerDetached</code>","text":"<p>This event is emitted when a logger has been detached from the transport.</p> Argument Types Description <code>logger</code> <code>Logger</code> The logger that was detached."},{"location":"guide/transports/#rotated","title":"<code>rotated</code>","text":"<p>This event is emitted when the log file is rotated.</p> Argument Types Description <code>file</code> <code>object</code> Details about the rotated log file."},{"location":"guide/transports/#cleaned","title":"<code>cleaned</code>","text":"<p>This event is emitted when an archived log file is deleted due to expiry.</p> Argument Types Description <code>file</code> <code>object</code> Details about the deleted log file."},{"location":"guide/transports/#empty","title":"<code>empty</code>","text":"<p>This event is emitted when the internal write buffer is emptied.</p>"},{"location":"guide/transports/#closing_transports","title":"Closing transports","text":"<p>All transports have a <code>close()</code> method that should be called when the application is being terminated, either by a <code>process.exit()</code> invocation or by an exit signal (such as <code>SIGINT</code>).</p> <p>The following example will gracefully close all transports that have been attached to the logger.</p> <pre><code>await Promise.all(\n    logger.transports.map(transport =&gt; transport.close())\n);\n</code></pre>"},{"location":"guide/transports/#creating_custom_transports","title":"Creating custom transports","text":""},{"location":"guide/transports/#basic_template","title":"Basic template","text":"<p>Transports receive an object each time a logger emits output. This object contains the logger, the logging level, the timestamp, and an array of raw arguments that were passed to the logger.</p> <pre><code>import { Transport } from '@baileyherbert/logging';\n\nexport class CustomTransport extends Transport {\n\n    /**\n     * Invoked when output is received from an attached logger.\n     */\n    protected onLoggerOutput(output: LoggerOutput) {\n        console.log(...output.args);\n    }\n\n}\n</code></pre>"},{"location":"guide/transports/#dealing_with_promises","title":"Dealing with promises","text":"<p>In some cases, a transport might need to deliver output asynchronously. You may also need to implement an internal queue to accept new output while still delivering previous output. This responsibility for these lie solely with the transport.</p>"}]}